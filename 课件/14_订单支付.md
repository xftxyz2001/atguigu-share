

# 订单支付

[TOC]

## 1、订单列表

### 1.1、OrderInfoApiController

```java
@Operation(summary = "获取用户订单分页列表")
@RequiresLogin
@GetMapping("/userOrderInfoList/{pageNum}/{pageSize}")
public TableDataInfo list(
        @Parameter(name = "pageNum", description = "当前页码", required = true)
        @PathVariable Integer pageNum,
        @Parameter(name = "pageSize", description = "每页记录数", required = true)
        @PathVariable Integer pageSize) {
    PageHelper.startPage(pageNum, pageSize);
    List<OrderInfo> list = orderInfoService.selectUserOrderInfoList(SecurityContextHolder.getUserId());
    return getDataTable(list);
}
```

### 1.2、IOrderInfoService

```java
List<OrderInfo> selectUserOrderInfoList(Long userId);
```

### 1.3、OrderInfoServiceImpl

```java
@Override
public List<OrderInfo> selectUserOrderInfoList(Long userId) {
    List<OrderInfo> orderInfoList = orderInfoMapper.selectList(new LambdaQueryWrapper<OrderInfo>()
            .eq(OrderInfo::getUserId, userId)
            .orderByDesc(OrderInfo::getId)
    );
    if (!CollectionUtils.isEmpty(orderInfoList)) {
        for (OrderInfo orderInfo : orderInfoList) {
            //充电中实时计算使用时间与金额
            if ("0".equals(orderInfo.getStatus())) {
                //充电中实时计算使用时间
                int duration = Minutes.minutesBetween(new DateTime(orderInfo.getStartTime()), new DateTime()).getMinutes();
                if (duration > 0) {
                    orderInfo.setDuration(duration);

                    // 费用计算
                    FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();
                    feeRuleRequestForm.setDuration(duration);
                    feeRuleRequestForm.setFeeRuleId(orderInfo.getFeeRuleId());
                    R<FeeRuleResponseVo> feeRuleResponseVoResult = remoteFeeRuleService.calculateOrderFee(feeRuleRequestForm, SecurityConstants.INNER);
                    if (R.FAIL == feeRuleResponseVoResult.getCode()) {
                        throw new ServiceException(feeRuleResponseVoResult.getMsg());
                    }
                    FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();

                    // 设置订单金额
                    orderInfo.setTotalAmount(feeRuleResponseVo.getTotalAmount());
                    orderInfo.setDeductAmount(new BigDecimal(0));
                    orderInfo.setRealAmount(feeRuleResponseVo.getTotalAmount());
                } else {
                    orderInfo.setDuration(0);
                    orderInfo.setTotalAmount(new BigDecimal(0));
                    orderInfo.setDeductAmount(new BigDecimal(0));
                    orderInfo.setRealAmount(new BigDecimal(0));
                }

            }
        }
    }
    return orderInfoList;
}
```



## 2、订单详情

充电中的订单计算使用时间与费用金额

### 2.1、OrderInfoApiController

```java
@Operation(summary = "获取订单详细信息")
@RequiresLogin
@GetMapping(value = "/getOrderInfo/{id}")
public AjaxResult getOrderInfo(@PathVariable("id") Long id)
{
    return success(orderInfoService.selectOrderInfoById(id));
}
```

### 2.2、OrderInfoServiceImpl

```java
@Override
public OrderInfo selectOrderInfoById(Long id) {
    OrderInfo orderInfo = orderInfoMapper.selectById(id);

    //充电中实时计算使用时间与金额
    if ("0".equals(orderInfo.getStatus())) {
        //充电中实时计算使用时间
        int duration = Minutes.minutesBetween(new DateTime(orderInfo.getStartTime()), new DateTime()).getMinutes();
        if (duration > 0) {
            orderInfo.setDuration(duration);

            // 费用计算
            FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();
            feeRuleRequestForm.setDuration(duration);
            feeRuleRequestForm.setFeeRuleId(orderInfo.getFeeRuleId());
            R<FeeRuleResponseVo> feeRuleResponseVoResult = remoteFeeRuleService.calculateOrderFee(feeRuleRequestForm, SecurityConstants.INNER);
            if (R.FAIL == feeRuleResponseVoResult.getCode()) {
                throw new ServiceException(feeRuleResponseVoResult.getMsg());
            }
            FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();

            // 设置订单金额
            orderInfo.setTotalAmount(feeRuleResponseVo.getTotalAmount());
            orderInfo.setDeductAmount(new BigDecimal(0));
            orderInfo.setRealAmount(feeRuleResponseVo.getTotalAmount());
        } else {
            orderInfo.setDuration(0);
            orderInfo.setTotalAmount(new BigDecimal(0));
            orderInfo.setDeductAmount(new BigDecimal(0));
            orderInfo.setRealAmount(new BigDecimal(0));
        }
    }

    List<OrderBill> orderBillList = orderBillMapper.selectList(new LambdaQueryWrapper<OrderBill>().eq(OrderBill::getOrderId, id));
    orderInfo.setOrderBillList(orderBillList);

    R<UserInfo> userInfoResult = remoteUserInfoService.getUserInfo(orderInfo.getUserId(), SecurityConstants.INNER);
    if (StringUtils.isNull(userInfoResult) || StringUtils.isNull(userInfoResult.getData())) {
        throw new ServiceException("获取用户信息失败");
    }
    if (R.FAIL == userInfoResult.getCode()) {
        throw new ServiceException(userInfoResult.getMsg());
    }
    UserInfoVo userInfoVo = new UserInfoVo();
    BeanUtils.copyProperties(userInfoResult.getData(), userInfoVo);
    orderInfo.setUserInfoVo(userInfoVo);
    return orderInfo;
}
```



## 3、微信支付

接口文档入口：

https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestPayment.html

https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_1.shtml

### 3.1、搭建支付管理模块

#### 3.1.1、新建share-payment模块

在share-modules模块下新建子模块share-payment

#### 3.1.2、pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>com.share</groupId>
        <artifactId>share-modules</artifactId>
        <version>3.6.3</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>share-payment</artifactId>

    <description>
        share-payment订单模块
    </description>

    <dependencies>
        <!-- SpringCloud Alibaba Nacos -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>

        <!-- SpringCloud Alibaba Nacos Config -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>

        <!-- SpringCloud Alibaba Sentinel -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>

        <!-- SpringBoot Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Mysql Connector -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
        </dependency>

        <!-- RuoYi Common DataScope -->
        <dependency>
            <groupId>com.share</groupId>
            <artifactId>share-common-datascope</artifactId>
        </dependency>

        <!-- RuoYi Common Log -->
        <dependency>
            <groupId>com.share</groupId>
            <artifactId>share-common-log</artifactId>
        </dependency>

        <dependency>
            <groupId>com.github.wechatpay-apiv3</groupId>
            <artifactId>wechatpay-java</artifactId>
        </dependency>
    </dependencies>

    <build>
        <finalName>${project.artifactId}</finalName>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

#### 3.1.3、banner.txt

在resources目录下新建banner.txt

```text
Spring Boot Version: ${spring-boot.version}
Spring Application Name: ${spring.application.name}
                            _                           _                    
                           (_)                         | |                   
 _ __  _   _   ___   _   _  _  ______  ___  _   _  ___ | |_   ___  _ __ ___  
| '__|| | | | / _ \ | | | || ||______|/ __|| | | |/ __|| __| / _ \| '_ ` _ \ 
| |   | |_| || (_) || |_| || |        \__ \| |_| |\__ \| |_ |  __/| | | | | |
|_|    \__,_| \___/  \__, ||_|        |___/ \__, ||___/ \__| \___||_| |_| |_|
                      __/ |                  __/ |                           
                     |___/                  |___/                            
```

#### 3.1.4、bootstrap.yml

在resources目录下新建bootstrap.yml

```yaml
# Tomcat
server:
  port: 9211

# Spring
spring:
  application:
    # 应用名称
    name: share-payment
  profiles:
    # 环境配置
    active: dev
  main:
    allow-bean-definition-overriding: true #当遇到同样名字的时候，是否允许覆盖注册
  cloud:
    nacos:
      discovery:
        # 服务注册地址
        server-addr: 127.0.0.1:8848
      config:
        # 配置中心地址
        server-addr: 127.0.0.1:8848
        # 配置文件格式
        file-extension: yml
        # 共享配置
        shared-configs:
          - application-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}
```

#### 3.1.5、share-payment-dev.yml

在nacos上添加商品服务配置文件

```yaml
mybatis-plus:
  mapper-locations: classpath*:mapper/**/*Mapper.xml
  type-aliases-package: com.share.**.domain
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 查看日志
  global-config:
    db-config:
      logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 2 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
# spring配置
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/share-payment?characterEncoding=utf-8&useSSL=false
    username: root
    password: root
    hikari:
      connection-test-query: SELECT 1
      connection-timeout: 60000
      idle-timeout: 500000
      max-lifetime: 540000
      maximum-pool-size: 10
      minimum-idle: 5
      pool-name: GuliHikariPool
```

#### 3.1.6、logback.xml

在resources目录下新建logback.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="60 seconds" debug="false">
    <!-- 日志存放路径 -->
   <property name="log.path" value="logs/share-payment" />
   <!-- 日志输出格式 -->
   <property name="log.pattern" value="%d{HH:mm:ss.SSS} [%thread] %-5level %logger{20} - [%method,%line] - %msg%n" />

    <!-- 控制台输出 -->
   <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
      <encoder>
         <pattern>${log.pattern}</pattern>
      </encoder>
   </appender>

    <!-- 系统日志输出 -->
   <appender name="file_info" class="ch.qos.logback.core.rolling.RollingFileAppender">
       <file>${log.path}/info.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
      <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
         <fileNamePattern>${log.path}/info.%d{yyyy-MM-dd}.log</fileNamePattern>
         <!-- 日志最大的历史 60天 -->
         <maxHistory>60</maxHistory>
      </rollingPolicy>
      <encoder>
         <pattern>${log.pattern}</pattern>
      </encoder>
      <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>INFO</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
   </appender>

    <appender name="file_error" class="ch.qos.logback.core.rolling.RollingFileAppender">
       <file>${log.path}/error.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${log.path}/error.%d{yyyy-MM-dd}.log</fileNamePattern>
         <!-- 日志最大的历史 60天 -->
         <maxHistory>60</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${log.pattern}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>ERROR</level>
         <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
         <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 系统模块日志级别控制  -->
   <logger name="com.share" level="info" />
   <!-- Spring日志级别控制  -->
   <logger name="org.springframework" level="warn" />

   <root level="info">
      <appender-ref ref="console" />
   </root>

   <!--系统操作日志-->
    <root level="info">
        <appender-ref ref="file_info" />
        <appender-ref ref="file_error" />
    </root>
</configuration>
```

#### 3.1.7、SharePaymentApplication

添加启动类

```java
package com.share.payment;

@EnableCustomConfig
@EnableRyFeignClients
@SpringBootApplication
public class SharePaymentApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(SharePaymentApplication.class, args);
        System.out.println("(♥◠‿◠)ﾉﾞ  支付模块启动成功   ლ(´ڡ`ლ)ﾞ  \n" +
                " .-------.       ____     __        \n" +
                " |  _ _   \\      \\   \\   /  /    \n" +
                " | ( ' )  |       \\  _. /  '       \n" +
                " |(_ o _) /        _( )_ .'         \n" +
                " | (_,_).' __  ___(_ o _)'          \n" +
                " |  |\\ \\  |  ||   |(_,_)'         \n" +
                " |  | \\ `'   /|   `-'  /           \n" +
                " |  |  \\    /  \\      /           \n" +
                " ''-'   `'-'    `-..-'              ");
    }
}

```

#### 3.1.8、share-gateway-dev.yml

配置网关

```yaml
# 支付服务
- id: share-payment
  uri: lb://share-payment
  predicates:
    - Path=/payment/**
  filters:
    - StripPrefix=1
```

### 3.2、根据订单号获取订单接口

#### 3.2.1、订单微服务接口

##### OrderInfoApiController

```java
@Operation(summary = "根据订单号获取订单信息")
@InnerAuth
@GetMapping("getByOrderNo/{orderNo}")
public R<OrderInfo> getByOrderNo(@PathVariable String orderNo) {
    OrderInfo orderInfo = orderInfoService.getByOrderNo(orderNo);
    return R.ok(orderInfo);
}
```

##### IOrderInfoService

```
OrderInfo getByOrderNo(String orderNo);
```

##### OrderInfoServiceImpl

```java
@Override
public OrderInfo getByOrderNo(String orderNo) {
    return orderInfoMapper.selectOne(new LambdaQueryWrapper<OrderInfo>().eq(OrderInfo::getOrderNo, orderNo));
}
```

#### 3.2.2、Feign接口

##### RemoteOrderInfoService

```java
@GetMapping("/orderInfo/getByOrderNo/{orderNo}")
public R<OrderInfo> getByOrderNo(@PathVariable("orderNo") String orderNo, @RequestHeader(SecurityConstants.FROM_SOURCE) String source);
```

##### RemoteOrderInfoFallbackFactory

```java
@Override
public R<OrderInfo> getByOrderNo(String orderNo, String source) {
    return R.fail("根据订单号获取订单信息失败:" + throwable.getMessage());
}
```

### 3.3、封装保存支付信息方法

#### 3.3.1、PaymentInfo

```java
package com.share.payment.domian;


@Data
@Schema(description = "PaymentInfo")
public class PaymentInfo extends BaseEntity {

    private static final long serialVersionUID = 1L;

    @Schema(description = "用户id")
    private Long userId;

    @Schema(description = "订单号")
    private String orderNo;

    @Schema(description = "付款方式：1-微信")
    private Integer payWay;

    @Schema(description = "交易编号（微信或支付）")
    private String transactionId;

    @Schema(description = "支付金额")
    private BigDecimal amount;

    @Schema(description = "交易内容")
    private String content;

    @Schema(description = "支付状态：0-未支付 1-已支付 -1-关闭交易")
    private Integer paymentStatus;

    @Schema(description = "回调时间")
    private Date callbackTime;

    @Schema(description = "回调信息")
    private String callbackContent;

}
```

#### 3.3.2、PaymentInfoMapper

```java
package com.share.payment.mapper;


@Mapper
public interface PaymentInfoMapper extends BaseMapper<PaymentInfo> {

}
```

#### 3.3.3、IPaymentInfoService

```java
package com.share.payment.service;


public interface IPaymentInfoService extends IService<PaymentInfo> {


    PaymentInfo savePaymentInfo(String orderNo);

}
```

#### 3.3.4、PaymentInfoServiceImpl

```java
package com.share.payment.service.impl;

@Slf4j
@Service
@SuppressWarnings({"unchecked", "rawtypes"})
public class PaymentInfoServiceImpl extends ServiceImpl<PaymentInfoMapper, PaymentInfo> implements IPaymentInfoService {

   @Autowired
   private PaymentInfoMapper paymentInfoMapper;

   @Autowired
   private RemoteOrderInfoService remoteOrderInfoService;

   @Override
   public PaymentInfo savePaymentInfo(String orderNo) {
      PaymentInfo paymentInfo = paymentInfoMapper.selectOne(new LambdaQueryWrapper<PaymentInfo>().eq(PaymentInfo::getOrderNo, orderNo));
      if(null == paymentInfo) {
         R<OrderInfo> orderInfoResult = remoteOrderInfoService.getByOrderNo(orderNo, SecurityConstants.INNER);
         if (R.FAIL == orderInfoResult.getCode()) {
            throw new ServiceException(orderInfoResult.getMsg());
         }
         OrderInfo orderInfo = orderInfoResult.getData();

         paymentInfo = new PaymentInfo();
         paymentInfo.setUserId(orderInfo.getUserId());
         paymentInfo.setContent("共享充电宝租借");
         paymentInfo.setAmount(orderInfo.getTotalAmount());
         paymentInfo.setOrderNo(orderNo);
         paymentInfo.setPaymentStatus(0);
         paymentInfoMapper.insert(paymentInfo);
      }
      if(paymentInfo.getPaymentStatus().intValue() == -1) {
         throw new ServiceException("订单已关闭");
      }
      return paymentInfo;
   }

}
```

### 3.4、微信下单

#### 3.4.1、WxPayApiController

```java
package com.share.payment.api;

@Tag(name = "微信支付接口")
@RestController
@RequestMapping("/wxPay")
@Slf4j
public class WxPayApiController extends BaseController {

    @Autowired
    private IWxPayService wxPayService;

    @Autowired
    private IPaymentInfoService paymentInfoService;

    @RequiresLogin
    @Operation(summary = "微信下单")
    @PostMapping("/createWxPayment")
    public AjaxResult createWxPayment(@RequestBody CreateWxPaymentForm createWxPaymentForm) {
        WxPrepayVo wxPrepayVo = wxPayService.createWxPayment(createWxPaymentForm);
        return success(wxPrepayVo);
    }

}
```

#### 3.4.2、CreateWxPaymentForm

```java
package com.share.payment.domian;

@Data
public class CreateWxPaymentForm {

    @Schema(description = "订单号")
    private String orderNo;

}
```

#### 3.4.3、WxPrepayVo

```java
package com.share.payment.domian;

@Data
public class WxPrepayVo {

    @Schema(description = "公众号ID")
    private String appId;

    @Schema(description = "时间戳，自1970年以来的秒数")
    private String timeStamp;

    @Schema(description = "随机串")
    private String nonceStr;

    @Schema(description = "预支付交易会话标识")
    private String packageVal;

    @Schema(description = "微信签名方式")
    private String signType;

    @Schema(description = "微信签名")
    private String paySign;
}
```

#### 3.4.4、IWxPayService

```java
package com.share.payment.service;

public interface IWxPayService {

	WxPrepayVo createWxPayment(CreateWxPaymentForm createWxPaymentForm);

}
```

#### 3.4.5、WxPayServiceImpl

```java
package com.share.payment.service.impl;

@Service
@Slf4j
public class WxPayServiceImpl implements IWxPayService {

   @Autowired
   private IPaymentInfoService paymentInfoService;

   @Autowired
   private RemoteUserInfoService remoteUserInfoService;

   @Autowired
   private WxPayV3Properties wxPayV3Properties;

   @Autowired
   private RSAAutoCertificateConfig rsaAutoCertificateConfig;

   @Override
   public WxPrepayVo createWxPayment(CreateWxPaymentForm createWxPaymentForm) {
      try {
         //保存支付记录
         PaymentInfo paymentInfo = paymentInfoService.savePaymentInfo(createWxPaymentForm.getOrderNo());

         //获取用户信息
         R<UserInfo> userInfoResult = remoteUserInfoService.getUserInfo(paymentInfo.getUserId(), SecurityConstants.INNER);
         if (StringUtils.isNull(userInfoResult) || StringUtils.isNull(userInfoResult.getData())) {
            throw new com.share.common.core.exception.ServiceException("获取用户信息失败");
         }
         if (R.FAIL == userInfoResult.getCode()) {
            throw new com.share.common.core.exception.ServiceException(userInfoResult.getMsg());
         }
         String openid = userInfoResult.getData().getWxOpenId();

         // 构建service
         JsapiServiceExtension service = new JsapiServiceExtension.Builder().config(rsaAutoCertificateConfig).build();

         // request.setXxx(val)设置所需参数，具体参数可见Request定义
         PrepayRequest request = new PrepayRequest();
         Amount amount = new Amount();
         amount.setTotal(paymentInfo.getAmount().multiply(new BigDecimal(100)).intValue());
         request.setAmount(amount);
         request.setAppid(wxPayV3Properties.getAppid());
         request.setMchid(wxPayV3Properties.getMerchantId());
         request.setDescription(paymentInfo.getContent());
         request.setNotifyUrl(wxPayV3Properties.getNotifyUrl());
         request.setOutTradeNo(paymentInfo.getOrderNo());

         //获取用户信息
         Payer payer = new Payer();
         payer.setOpenid(openid);
         request.setPayer(payer);

         // 调用下单方法，得到应答
         // response包含了调起支付所需的所有参数，可直接用于前端调起支付
         PrepayWithRequestPaymentResponse response = service.prepayWithRequestPayment(request);
         log.info("微信支付下单返回参数：{}", JSON.toJSONString(response));

         WxPrepayVo wxPrepayVo = new WxPrepayVo();
         BeanUtils.copyProperties(response, wxPrepayVo);
         wxPrepayVo.setTimeStamp(response.getTimeStamp());

         return wxPrepayVo;
      } catch (ServiceException e) {
         e.printStackTrace();
         throw new com.share.common.core.exception.ServiceException(e.getErrorMessage());
      } catch (IllegalArgumentException e) {
         e.printStackTrace();
         throw new com.share.common.core.exception.ServiceException("订单号不存在");
      } catch (Exception e) {
         e.printStackTrace();
         throw new com.share.common.core.exception.ServiceException("微信下单异常");
      }
   }

}
```

#### 3.4.6、share-payment-dev.yml

```yaml
wx:
  v3pay:
    #小程序微信公众平台appId
    appid: wxcc651fcbab275e33
    #商户号
    merchantId: 1631833859
    #商户API私钥路径
    privateKeyPath: [具体路径]apiclient_key.pem
    #商户证书序列号
    merchantSerialNumber: 4AE80B52EBEAB2B96F68E02510A42801E952E889
    #商户APIV3密钥
    apiV3key: 84dba6dd51cdaf779e55bcabae564b53
    #异步回调地址
    notifyUrl: http://内网穿透地址:8600/payment/wxPay/notify
```

#### 3.4.7、WxPayV3Properties

```java
package com.share.payment.config;

import com.wechat.pay.java.core.RSAAutoCertificateConfig;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix="wx.v3pay") //读取节点
@Data
public class WxPayV3Properties {

    private String appid;
    /** 商户号 */
    public String merchantId;
    /** 商户API私钥路径 */
    public String privateKeyPath;
    /** 商户证书序列号 */
    public String merchantSerialNumber;
    /** 商户APIV3密钥 */
    public String apiV3key;
    /** 回调地址 */
    private String notifyUrl;

    @Bean
    public RSAAutoCertificateConfig getConfig(){
        return new RSAAutoCertificateConfig.Builder()
                        .merchantId(this.getMerchantId())
                        .privateKeyFromPath(this.getPrivateKeyPath())
                        .merchantSerialNumber(this.getMerchantSerialNumber())
                        .apiV3Key(this.getApiV3key())
                        .build();

    }
}
```

### 3.5、支付结果通知

官方文档地址：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_5.shtml

支付成功，微信平台异步通知，我们处理完支付微服务业务逻辑后，快速返回，需要发送mq消息处理订单其他业务，因此我们要引入mq消息队列。

#### 3.5.1、pom.xml

```xml
<dependency>
    <groupId>com.share</groupId>
    <artifactId>share-common-rabbit</artifactId>
    <version>3.6.3</version>
</dependency>
```

#### share-payment-dev.yml

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    publisher-confirm-type: CORRELATED
    publisher-returns: true
    listener:
      simple:
        cknowledge-mode: manual #默认情况下消息消费者是自动确认消息的，如果要手动确认消息则需要修改确认模式为manual
        prefetch: 1 # 消费者每次从队列获取的消息数量。此属性当不设置时为：轮询分发，设置为1为：公平分发
```

#### 3.5.3、WxPayApiController

```java
/https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_5.shtml
@Operation(summary = "微信支付异步通知接口")
@PostMapping("/notify")
public Map<String, Object> notify(HttpServletRequest request) {
    try {
        wxPayService.wxnotify(request);

        //返回成功
        Map<String, Object> result = new HashMap<>();
        result.put("code", "SUCCESS");
        result.put("message", "成功");
        return result;
    } catch (Exception e) {
        e.printStackTrace();
    }

    //返回失败
    Map<String, Object> result = new HashMap<>();
    result.put("code", "FAIL");
    result.put("message", "失败");
    return result;
}
```

#### 3.5.4、IWxPayService

```java
void wxnotify(HttpServletRequest request);
```

#### 3.5.5、WxPayServiceImpl

```java
@Override
public void wxnotify(HttpServletRequest request) {
   //1.回调通知的验签与解密
   //从request头信息获取参数
   //HTTP 头 Wechatpay-Signature
   // HTTP 头 Wechatpay-Nonce
   //HTTP 头 Wechatpay-Timestamp
   //HTTP 头 Wechatpay-Serial
   //HTTP 头 Wechatpay-Signature-Type
   //HTTP 请求体 body。切记使用原始报文，不要用 JSON 对象序列化后的字符串，避免验签的 body 和原文不一致。
   String wechatPaySerial = request.getHeader("Wechatpay-Serial");
   String nonce = request.getHeader("Wechatpay-Nonce");
   String timestamp = request.getHeader("Wechatpay-Timestamp");
   String signature = request.getHeader("Wechatpay-Signature");
   String requestBody = RequestUtils.readData(request);
   log.info("wechatPaySerial：{}", wechatPaySerial);
   log.info("nonce：{}", nonce);
   log.info("timestamp：{}", timestamp);
   log.info("signature：{}", signature);
   log.info("requestBody：{}", requestBody);

   //2.构造 RequestParam
   RequestParam requestParam = new RequestParam.Builder()
         .serialNumber(wechatPaySerial)
         .nonce(nonce)
         .signature(signature)
         .timestamp(timestamp)
         .body(requestBody)
         .build();


   //3.初始化 NotificationParser
   NotificationParser parser = new NotificationParser(rsaAutoCertificateConfig);
   //4.以支付通知回调为例，验签、解密并转换成 Transaction
   Transaction transaction = parser.parse(requestParam, Transaction.class);
   log.info("成功解析：{}", JSON.toJSONString(transaction));
   if(null != transaction && transaction.getTradeState() == Transaction.TradeStateEnum.SUCCESS) {
      //5.处理支付业务
      paymentInfoService.updatePaymentStatus(transaction);
   }
}
```

#### 3.5.6、RequestUtils

```java
package com.share.payment.util;

public class RequestUtils {

    /**
     * 将通知参数转化为字符串
     * @param request
     * @return
     */
    public static String readData(HttpServletRequest request) {
        BufferedReader br = null;
        try {
            StringBuilder result = new StringBuilder();
            br = request.getReader();
            for (String line; (line = br.readLine()) != null; ) {
                if (result.length() > 0) {
                    result.append("\n");
                }
                result.append(line);
            }
            return result.toString();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

#### 3.5.7、IPaymentInfoService

```java
void updatePaymentStatus(Transaction transaction);
```

#### 3.5.8、PaymentInfoServiceImpl

```java
@Transactional(rollbackFor = Exception.class)
@Override
public void updatePaymentStatus(Transaction transaction) {
   PaymentInfo paymentInfo = paymentInfoMapper.selectOne(new LambdaQueryWrapper<PaymentInfo>().eq(PaymentInfo::getOrderNo, transaction.getOutTradeNo()));
   //1.已支付，直接返回
   if (paymentInfo.getPaymentStatus() == 1) {
      return;
   }

   //更新支付信息
   paymentInfo.setPaymentStatus(1);
   paymentInfo.setOrderNo(transaction.getOutTradeNo());
   paymentInfo.setTransactionId(transaction.getTransactionId());
   paymentInfo.setCallbackTime(new Date());
   paymentInfo.setCallbackContent(com.alibaba.fastjson.JSON.toJSONString(transaction));
   this.updateById(paymentInfo);

   //基于MQ通知订单系统，修改订单状态
   rabbitService.sendMessage(MqConst.EXCHANGE_PAYMENT_PAY, MqConst.ROUTING_PAYMENT_PAY, paymentInfo.getOrderNo());
}
```

### 3.6、支付查询

微信支付调用成功与失败 不能够完全依据前端 **success**，**fail** 回调函数来进行判断 , 判断是否支付成功，由后端进行判断。因此在发起支付后，小程序要轮询查询后端是否支付成功。

微信支付查询订单文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_2.shtml

#### 3.6.1、WxPayApiController

```java
@Autowired
private IPaymentInfoService paymentInfoService;

@RequiresLogin
@Operation(summary = "支付状态查询")
@GetMapping("/queryPayStatus/{orderNo}")
public AjaxResult queryPayStatus(@PathVariable String orderNo) {
    try {
        //调用查询接口
        Transaction transaction = wxPayService.queryPayStatus(orderNo);
        System.out.println("queryPayStatus: " + JSON.toJSONString(transaction));
        if (null != transaction && transaction.getTradeState() == Transaction.TradeStateEnum.SUCCESS) {
            //更改订单状态
            paymentInfoService.updatePaymentStatus(transaction);
            return success(true);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return success(false);
}
```

#### 3.6.2、IWxPayService

```java
Transaction queryPayStatus(String orderNo);
```

```java
@Override
public Transaction queryPayStatus(String orderNo) {
   // 构建service
   JsapiServiceExtension service = new JsapiServiceExtension.Builder().config(rsaAutoCertificateConfig).build();

   QueryOrderByOutTradeNoRequest queryRequest = new QueryOrderByOutTradeNoRequest();
   queryRequest.setMchid(wxPayV3Properties.getMerchantId());
   queryRequest.setOutTradeNo(orderNo);

   try {
      Transaction result = service.queryOrderByOutTradeNo(queryRequest);
      log.info(JSON.toJSONString(result));
      return result;
   } catch (ServiceException e) {
      // API返回失败, 例如ORDER_NOT_EXISTS
      System.out.printf("code=[%s], message=[%s]\n", e.getErrorCode(), e.getErrorMessage());
      System.out.printf("reponse body=[%s]\n", e.getResponseBody());
   }
   return null;
}
```



## 4、支付成功订单业务处理

前面支付成功了，微信平台也回调了，只要我们支付记录表记录了支付信息与更改了支付状态，我们就让他快速返回，后面的业务我们通过mq来保证最终的一致。

后续还有哪些业务要处理呢？

更改订单状态

### 4.1、OrderReceiver

```java
/**
     * 监听订单支付成功消息：更新订单状态；扣减商品库存
     *
     * @param orderNo
     * @param message
     * @param channel
     */
@SneakyThrows
@RabbitListener(bindings = @QueueBinding(
    exchange = @Exchange(value = MqConst.EXCHANGE_PAYMENT_PAY, durable = "true"),
    value = @Queue(value = MqConst.QUEUE_PAYMENT_PAY, durable = "true"),
    key = MqConst.ROUTING_PAYMENT_PAY
    ))
public void processPaySucess(String orderNo, Message message, Channel channel) {
    //业务处理
    if (StringUtils.isNotEmpty(orderNo)) {
        log.info("[订单服务]监听订单支付成功消息：{}", orderNo);
        //更改订单支付状态
        orderInfoService.processPaySucess(orderNo);
    }
    //手动应答
    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
}
```

### 4.2、IOrderInfoService

```
void processPaySucess(String orderNo);
```

### 4.3、OrderInfoServiceImpl

```java
@Override
public void processPaySucess(String orderNo) {
    //获取订单信息
    OrderInfo orderInfo = orderInfoMapper.selectOne(new LambdaQueryWrapper<OrderInfo>().eq(OrderInfo::getOrderNo, orderNo).select(OrderInfo::getId, OrderInfo::getStatus));
    //未支付
    if ("1".equals(orderInfo.getStatus())) {
        orderInfo.setStatus("2");
        orderInfo.setPayTime(new Date());
        orderInfoMapper.updateById(orderInfo);
    }
}
```